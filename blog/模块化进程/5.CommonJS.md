## 1.概念

- Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。

## 2.特点

- 所有代码都运行在模块作用域，不会污染全局作用域；
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存；
- 模块加载的顺序，按照其在代码中出现的顺序；

> 此处我们有个疑问：CommonJS 暴露的模块到底是什么?

- CommonJS 规范规定，每个模块内部，`module 变量代表当前模块`。这个变量是一个对象，它的 `exports 属性（即 module.exports）是对外的接口`。加载某个模块，其实是加载该模块的 module.exports 属性。

```javascript
// example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;

// index.js

var example = require("./example.js");

console.log(example.x); // 5
console.log(example.addX(1)); // 6
```

## 4. 模块的加载机制

CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。这点与 ES6 模块化有重大差异（下文会介绍），请看下面这个例子：

```javascript
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};

// main.js
var counter = require("./lib").counter;
var incCounter = require("./lib").incCounter;

console.log(counter); // 3
incCounter();
console.log(counter); // 3 说明lib.js模块内部的变化就影响不到counter了
```

## 5. 服务器端实现

1. 安装 node
2. npm init
3. node main.js

## 6. 浏览器端实现
